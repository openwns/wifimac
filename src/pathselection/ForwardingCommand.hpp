/******************************************************************************
 * WiFiMac                                                                    *
 * This file is part of openWNS (open Wireless Network Simulator)
 * _____________________________________________________________________________
 *
 * Copyright (C) 2004-2007
 * Chair of Communication Networks (ComNets)
 * Kopernikusstr. 16, D-52074 Aachen, Germany
 * phone: ++49-241-80-27910,
 * fax: ++49-241-80-22242
 * email: info@openwns.org
 * www: http://www.openwns.org
 * _____________________________________________________________________________
 *
 * openWNS is free software; you can redistribute it and/or modify it under the
 * terms of the GNU Lesser General Public License version 2 as published by the
 * Free Software Foundation;
 *
 * openWNS is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more
 * details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 ******************************************************************************/

#ifndef WIFIMAC_PATHSELECTION_FORWARDINGCOMMAND_HPP
#define WIFIMAC_PATHSELECTION_FORWARDINGCOMMAND_HPP

#include <WNS/ldk/Command.hpp>
#include <WNS/service/dll/Address.hpp>


namespace wifimac { namespace pathselection {

    class ForwardingCommand :
        public wns::ldk::Command
    {
    public:
        ForwardingCommand()
            {
                peer.TTL = 0;
                peer.toDS = false;
                peer.fromDS = false;
                peer.addressExtension = false;
                peer.finalDestination = wns::service::dll::UnicastAddress();
                peer.originalSource = wns::service::dll::UnicastAddress();
                peer.meshSource = wns::service::dll::UnicastAddress();
                peer.meshDestination = wns::service::dll::UnicastAddress();

                magic.hopCount = 0;
                magic.isUplink = false;

                magic.path.clear();
            }
        struct {} local;

        /**
		 * @brief 6-field Addressing in a mesh
		 *
		 * originalSource -> meshSource -> uc.sourceMACAddress
		 *      --> (current transmission) -->
		 * uc.targetMACAddress -> meshDestination -> finalDestination
		 *
		 */
        struct {
            /**
             * @brief Time to live (number of hops in the mesh) to avoid circles
             */
            int TTL;

            /**
             * @brief Flag signalling frames to the distribution system
             */
            bool toDS;

            /**
             * @brief Flag signalling frames from the distribution system
             */
            bool fromDS;

            /**
             * @brief Flag signalling that the 6-field mesh address extension is used
             */
            bool addressExtension;

            /**
             * @brief First node in the mesh that the frame has passed through.
             *
             * Only valid if the addressExtension is set to true
             */
            wns::service::dll::UnicastAddress meshSource;


            /**
             * @brief Destination in the mesh
             *
             * Only valid if the addressExtension is set to true
             */
            wns::service::dll::UnicastAddress meshDestination;

            /**
             * @brief Source of the frame
             */
            wns::service::dll::UnicastAddress originalSource;

            /**
             * @brief Sink of the frame
             */
            wns::service::dll::UnicastAddress finalDestination;

        } peer;

        struct {
            /**
             * @brief Storage of the hops this frame has passed so far.
             */
            std::vector<wns::service::dll::UnicastAddress> path;

            /**
             * @brief Number of hops this frame has passed so far
             */
            int hopCount;

            /**
             * @brief Identifies uplink frames (generated by a STA)
             */
            bool isUplink;
        } magic;
    };
}
}
#endif // WIFIMAC_PATHSELECTION_FORWARDINGCOMMAND_HPP
